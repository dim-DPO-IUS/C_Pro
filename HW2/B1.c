#include <stdio.h>
#include <stdlib.h>

/*
Описана структура данных для хранения информации об использованной памяти:  

typedef struct list {  
void *address;  
size_t size;  
char comment[64];  
struct list *next;  
} list;  

Требуется реализовать только одну функцию, которая анализирует данный с
писок и возвращает сколько всего памяти используется. Адрес хранится в 
поле address, поле size - соответствующий размер данного блока. Если 
список пустой, то функция должна возвращать 0.  
Прототип функции:

size_t totalMemoryUsage(list *head)
*/


// Структура для хранения информации о блоке памяти
// Каждый элемент списка содержит:
// - address: указатель на начало блока памяти
// - size: размер блока в байтах (тип size_t для совместимости с malloc)
// - comment: строковый комментарий к блоку (не используется в этой задаче)
// - next: указатель на следующий элемент в односвязном списке
typedef struct list {
    void *address;     // Адрес начала блока памяти
    size_t size;       // Размер блока памяти в байтах
    char comment[64];  // Комментарий к блоку (не используется при подсчёте)
    struct list *next; // Указатель на следующий элемент списка
} list;

// Функция totalMemoryUsage - основная функция по заданию
// Назначение: вычислить общий объем памяти, используемый всеми блоками в списке
// Параметры:
//   head - указатель на первый элемент списка (голову списка)
// Возвращаемое значение:
//   size_t - суммарный размер всех блоков памяти в списке в байтах
//   Если список пустой (head == NULL), возвращает 0
size_t totalMemoryUsage(list *head) {
    size_t total = 0;      // Инициализация переменной для накопления суммы
    list *current = head;  // Создаём указатель для обхода списка, не изменяя head
    
    // Цикл while проходит по всем элементам списка
    // Условие: пока текущий указатель не равен NULL (не достигли конца списка)
    while (current != NULL) {
        // Добавляем размер текущего блока к общей сумме
        // Используем только поле size, адрес и комментарий игнорируются
        total += current->size;
        
        // Переходим к следующему элементу списка
        // current->next содержит адрес следующего узла или NULL, если это последний узел
        current = current->next;
    }
    
    return total;
}

// Главная функция программы
int main() {
    int n;             // Переменная для хранения количества блоков памяти
    list *head = NULL; // Указатель на начало (голову) списка, изначально список пуст
    list *tail = NULL; // Указатель на конец (хвост) списка для эффективного добавления
    
    // Чтение количества блоков памяти из стандартного ввода
    // Формат ввода: первое число - количество записей
    scanf("%d", &n);
    
    // Цикл для чтения информации о каждом блоке памяти
    // n - количество блоков
    for (int i = 0; i < n; i++) {
        unsigned long long addr;  // Переменная для хранения адреса (64-битное беззнаковое число)
        size_t size;              // Переменная для хранения размера блока
        
        // Чтение данных о блоке из стандартного ввода
        // Формат: адрес (целое число) и размер (целое число)
        // %llu - спецификатор для unsigned long long (адрес)
        // %zu - спецификатор для size_t (размер)
        scanf("%llu %zu", &addr, &size);
        
        // Выделение памяти для нового узла списка
        // sizeof(list) возвращает размер структуры list в байтах
        // malloc возвращает указатель на выделенную память или NULL при ошибке
        list *newNode = (list*)malloc(sizeof(list));
        
        // Инициализация полей нового узла:
        // Преобразуем числовой адрес в указатель void*
        newNode->address = (void*)addr;
        
        // Сохраняем размер блока памяти
        newNode->size = size;
        
        // Новый узел становится последним в списке, поэтому next = NULL
        newNode->next = NULL;
        
        // Добавление нового узла в список:
        // Если список пустой (head == NULL)
        if (head == NULL) {
            // Новый узел становится и первым и последним элементом
            head = newNode;     // Голова списка указывает на новый узел
            tail = newNode;     // Хвост списка также указывает на новый узел
        }
        // Если список не пустой
        else {
            // Добавляем новый узел после текущего хвоста
            tail->next = newNode;   // Текущий последний элемент теперь указывает на новый узел
            tail = newNode;         // Новый узел становится новым хвостом списка
        }
    }
    
    // Вычисление общего объема используемой памяти
    // Вызываем функцию totalMemoryUsage, передавая указатель на начало списка
    size_t result = totalMemoryUsage(head);
    
    // %zu - спецификатор для вывода значения типа size_t
    printf("%zu\n", result);
    
    // Освобождение динамически выделенной памяти (уборка, чтобы не было утечек памяти)
    // Проходим по списку и освобождаем каждый узел
    while (head != NULL) {
        list *temp = head;  // Сохраняем указатель на текущий узел
        head = head->next;  // Перемещаем голову на следующий узел
        free(temp);         // Освобождаем память, занятую текущим узлом
        // После free(temp) обращаться к temp или его полям нельзя
    }
    
    return 0;
}
